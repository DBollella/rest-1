<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Rest.Dictionary.Combinators</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Rest-Dictionary-Combinators.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Rest-Dictionary-Combinators.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">rest-core-0.31: Rest API library.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Rest.Dictionary.Combinators</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Input dictionaries</a></li><li><a href="#g:2">Output dictionaries</a></li><li><a href="#g:3">Error dictionaries</a></li><li><a href="#g:4">Composed dictionaries</a></li><li><a href="#g:5">Header dictionaries</a></li><li><a href="#g:6">Parameter dictionaries</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Combinators for specifying the input/output dictionaries of a
 <code>Handler</code>. The combinators can be combined using <code>(</code><code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Category.html#v:.">.</a></code><code>)</code>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:someI">someI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p () o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:stringI">stringI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> o e</li><li class="src short"><a href="#v:xmlTextI">xmlTextI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p Text o e</li><li class="src short"><a href="#v:fileI">fileI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p <a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> o e</li><li class="src short"><a href="#v:readI">readI</a> :: (<a href="Rest-Info.html#t:Info">Info</a> i, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Read.html#t:Read">Read</a> i, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> i) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:xmlI">xmlI</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> i, XmlPickler i) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:rawXmlI">rawXmlI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p <a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> o e</li><li class="src short"><a href="#v:jsonI">jsonI</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> i, FromJSON i, JSONSchema i) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:someO">someO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:stringO">stringO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> e</li><li class="src short"><a href="#v:fileO">fileO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i (<a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>) e</li><li class="src short"><a href="#v:xmlO">xmlO</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> o, XmlPickler o) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:rawXmlO">rawXmlO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i <a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> e</li><li class="src short"><a href="#v:jsonO">jsonO</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> o, ToJSON o, JSONSchema o) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:multipartO">multipartO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i [BodyPart] e</li><li class="src short"><a href="#v:someE">someE</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> e, ToJSON e, JSONSchema e) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o () -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:jsonE">jsonE</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> e, ToJSON e, JSONSchema e) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:xmlE">xmlE</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> e, XmlPickler e) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:xmlJsonI">xmlJsonI</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> i, FromJSON i, JSONSchema i, XmlPickler i) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p () o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:xmlJsonO">xmlJsonO</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> o, ToJSON o, JSONSchema o, XmlPickler o) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:xmlJsonE">xmlJsonE</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> e, ToJSON e, JSONSchema e, XmlPickler e) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o () -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:xmlJson">xmlJson</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> i, FromJSON i, JSONSchema i, XmlPickler i, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> o, ToJSON o, JSONSchema o, XmlPickler o) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p () () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:mkHeader">mkHeader</a> ::  <a href="Rest-Dictionary-Types.html#t:Header">Header</a> h -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> x p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:mkPar">mkPar</a> ::  <a href="Rest-Dictionary-Types.html#t:Param">Param</a> p -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h x i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li class="src short"><a href="#v:addPar">addPar</a> ::  <a href="Rest-Dictionary-Types.html#t:Param">Param</a> p -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p' i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h (p, p') i o e</li></ul></div><div id="interface"><h2 id="g:1">Input dictionaries</h2><div class="top"><p class="src"><a name="v:someI" class="def">someI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p () o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#someI" class="link">Source</a></p><div class="doc"><p>Open up input type for extension with custom dictionaries.</p></div></div><div class="top"><p class="src"><a name="v:stringI" class="def">stringI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> o e <a href="src/Rest-Dictionary-Combinators.html#stringI" class="link">Source</a></p><div class="doc"><p>Allow direct usage of as input as <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:xmlTextI" class="def">xmlTextI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p Text o e <a href="src/Rest-Dictionary-Combinators.html#xmlTextI" class="link">Source</a></p><div class="doc"><p>Allow direct usage of as input as raw Xml <code>Text</code>.</p></div></div><div class="top"><p class="src"><a name="v:fileI" class="def">fileI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p <a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> o e <a href="src/Rest-Dictionary-Combinators.html#fileI" class="link">Source</a></p><div class="doc"><p>Allow usage of input as file contents, represented as a <code><a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:readI" class="def">readI</a> :: (<a href="Rest-Info.html#t:Info">Info</a> i, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Read.html#t:Read">Read</a> i, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> i) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#readI" class="link">Source</a></p><div class="doc"><p>The input can be read into some instance of <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Read.html#t:Read">Read</a></code>. For inspection reasons
 the type must also be an instance of both <code><a href="Rest-Info.html#t:Info">Info</a></code> and <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:xmlI" class="def">xmlI</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> i, XmlPickler i) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#xmlI" class="link">Source</a></p><div class="doc"><p>The input can be read into some instance of <code>XmlPickler</code>.</p></div></div><div class="top"><p class="src"><a name="v:rawXmlI" class="def">rawXmlI</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p <a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> o e <a href="src/Rest-Dictionary-Combinators.html#rawXmlI" class="link">Source</a></p><div class="doc"><p>The input can be used as an XML <code><a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:jsonI" class="def">jsonI</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> i, FromJSON i, JSONSchema i) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#jsonI" class="link">Source</a></p><div class="doc"><p>The input can be read into some instance of <code>Json</code>.</p></div></div><h2 id="g:2">Output dictionaries</h2><div class="top"><p class="src"><a name="v:someO" class="def">someO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#someO" class="link">Source</a></p><div class="doc"><p>Open up output type for extension with custom dictionaries.</p></div></div><div class="top"><p class="src"><a name="v:stringO" class="def">stringO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> e <a href="src/Rest-Dictionary-Combinators.html#stringO" class="link">Source</a></p><div class="doc"><p>Allow output as plain String.</p></div></div><div class="top"><p class="src"><a name="v:fileO" class="def">fileO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i (<a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>) e <a href="src/Rest-Dictionary-Combinators.html#fileO" class="link">Source</a></p><div class="doc"><p>Allow file output using a combination of the raw data and a mime type.</p></div></div><div class="top"><p class="src"><a name="v:xmlO" class="def">xmlO</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> o, XmlPickler o) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#xmlO" class="link">Source</a></p><div class="doc"><p>Allow output as XML using the <code>XmlPickler</code> type class.</p></div></div><div class="top"><p class="src"><a name="v:rawXmlO" class="def">rawXmlO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i <a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> e <a href="src/Rest-Dictionary-Combinators.html#rawXmlO" class="link">Source</a></p><div class="doc"><p>Allow output as raw XML represented as a <code><a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:jsonO" class="def">jsonO</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> o, ToJSON o, JSONSchema o) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#jsonO" class="link">Source</a></p><div class="doc"><p>Allow output as JSON using the <code>Json</code> type class.</p></div></div><div class="top"><p class="src"><a name="v:multipartO" class="def">multipartO</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i [BodyPart] e <a href="src/Rest-Dictionary-Combinators.html#multipartO" class="link">Source</a></p><div class="doc"><p>Allow output as multipart. Writes out the ByteStrings separated
 by boundaries, with content type 'multipart/mixed'.</p></div></div><h2 id="g:3">Error dictionaries</h2><div class="top"><p class="src"><a name="v:someE" class="def">someE</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> e, ToJSON e, JSONSchema e) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o () -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#someE" class="link">Source</a></p><div class="doc"><p>Open up error type for extension with custom dictionaries.</p></div></div><div class="top"><p class="src"><a name="v:jsonE" class="def">jsonE</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> e, ToJSON e, JSONSchema e) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#jsonE" class="link">Source</a></p><div class="doc"><p>Allow error output as JSON using the <code>Json</code> type class.</p></div></div><div class="top"><p class="src"><a name="v:xmlE" class="def">xmlE</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> e, XmlPickler e) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#xmlE" class="link">Source</a></p><div class="doc"><p>Allow error output as XML using the <code>XmlPickler</code> type class.</p></div></div><h2 id="g:4">Composed dictionaries</h2><div class="top"><p class="src"><a name="v:xmlJsonI" class="def">xmlJsonI</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> i, FromJSON i, JSONSchema i, XmlPickler i) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p () o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#xmlJsonI" class="link">Source</a></p><div class="doc"><p>The input can be read into some instance of both <code>Json</code> and <code>XmlPickler</code>.</p></div></div><div class="top"><p class="src"><a name="v:xmlJsonO" class="def">xmlJsonO</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> o, ToJSON o, JSONSchema o, XmlPickler o) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#xmlJsonO" class="link">Source</a></p><div class="doc"><p>Allow output as JSON using the <code>Json</code> type class and allow output as XML
 using the <code>XmlPickler</code> type class.</p></div></div><div class="top"><p class="src"><a name="v:xmlJsonE" class="def">xmlJsonE</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> e, ToJSON e, JSONSchema e, XmlPickler e) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o () -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#xmlJsonE" class="link">Source</a></p><div class="doc"><p>Allow error output as JSON using the <code>Json</code> type class and allow output as
 XML using the <code>XmlPickler</code> type class.</p></div></div><div class="top"><p class="src"><a name="v:xmlJson" class="def">xmlJson</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> i, FromJSON i, JSONSchema i, XmlPickler i, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> o, ToJSON o, JSONSchema o, XmlPickler o) =&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p () () e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#xmlJson" class="link">Source</a></p><div class="doc"><p>The input can be read into some instance of both <code>Json</code> and <code>XmlPickler</code>
 and allow output as JSON using the <code>Json</code> type class and allow output as XML
 using the <code>XmlPickler</code> type class.</p></div></div><h2 id="g:5">Header dictionaries</h2><div class="top"><p class="src"><a name="v:mkHeader" class="def">mkHeader</a> ::  <a href="Rest-Dictionary-Types.html#t:Header">Header</a> h -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> x p i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#mkHeader" class="link">Source</a></p><div class="doc"><p>Add custom sub-dictionary for recognizing headers.</p></div></div><h2 id="g:6">Parameter dictionaries</h2><div class="top"><p class="src"><a name="v:mkPar" class="def">mkPar</a> ::  <a href="Rest-Dictionary-Types.html#t:Param">Param</a> p -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h x i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e <a href="src/Rest-Dictionary-Combinators.html#mkPar" class="link">Source</a></p><div class="doc"><p>Set custom sub-dictionary for recognizing parameters.</p></div></div><div class="top"><p class="src"><a name="v:addPar" class="def">addPar</a> ::  <a href="Rest-Dictionary-Types.html#t:Param">Param</a> p -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p' i o e -&gt; <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h (p, p') i o e <a href="src/Rest-Dictionary-Combinators.html#addPar" class="link">Source</a></p><div class="doc"><p>Add custom sub-dictionary for recognizing parameters.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.2</p></div></body></html>