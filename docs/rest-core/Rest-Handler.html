<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Rest.Handler</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Rest-Handler.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Rest-Handler.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">rest-core-0.31: Rest API library.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Rest.Handler</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Single handlers.</a></li><li><a href="#g:2">Listings.</a><ul><li><a href="#g:3">Parameter parsers for listings.</a></li></ul></li><li><a href="#g:4">Generic handlers and core data types.</a></li><li><a href="#g:5">Convenience functions.</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Handlers for endpoints in a <code>Resource</code>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:mkHandler">mkHandler</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> h p i o e -&gt; (<a href="Rest-Handler.html#t:Env">Env</a> h p i -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m o) -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m</li><li class="src short"><a href="#v:mkInputHandler">mkInputHandler</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> () () i o e -&gt; (i -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m o) -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m</li><li class="src short"><a href="#v:mkConstHandler">mkConstHandler</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> () () () o e -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m o -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m</li><li class="src short"><a href="#v:mkIdHandler">mkIdHandler</a> :: MonadReader id m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> h p i o e -&gt; (i -&gt; id -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m o) -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m</li><li class="src short"><a href="#v:mkListing">mkListing</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> () () () o e -&gt; (<a href="Rest-Handler.html#t:Range">Range</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m [o]) -&gt; <a href="Rest-Handler.html#t:ListHandler">ListHandler</a> m</li><li class="src short"><a href="#v:mkOrderedListing">mkOrderedListing</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> () () () o e -&gt; ((<a href="Rest-Handler.html#t:Range">Range</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>) -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m [o]) -&gt; <a href="Rest-Handler.html#t:ListHandler">ListHandler</a> m</li><li class="src short"><span class="keyword">data</span> <a href="#t:Range">Range</a> = <a href="#v:Range">Range</a> {<ul class="subs"><li><a href="#v:offset">offset</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a></li><li><a href="#v:count">count</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a></li></ul>}</li><li class="src short"><a href="#v:range">range</a> :: <a href="Rest-Dictionary-Types.html#t:Param">Param</a> <a href="Rest-Handler.html#t:Range">Range</a></li><li class="src short"><a href="#v:orderedRange">orderedRange</a> :: <a href="Rest-Dictionary-Types.html#t:Param">Param</a> (<a href="Rest-Handler.html#t:Range">Range</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>)</li><li class="src short"><span class="keyword">data</span> <a href="#t:Env">Env</a> h p i = <a href="#v:Env">Env</a> {<ul class="subs"><li><a href="#v:header">header</a> :: h</li><li><a href="#v:param">param</a> :: p</li><li><a href="#v:input">input</a> :: i</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:GenHandler">GenHandler</a> m f <span class="keyword">where</span><ul class="subs"><li><a href="#v:GenHandler">GenHandler</a> :: { <ul class="subs"><li><a href="#v:dictionary">dictionary</a> :: <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</li><li><a href="#v:handler">handler</a> :: <a href="Rest-Handler.html#t:Env">Env</a> h p i -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m (<a href="Rest-Handler.html#t:Apply">Apply</a> f o)</li><li><a href="#v:secure">secure</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li></ul> } -&gt; <a href="Rest-Handler.html#t:GenHandler">GenHandler</a> m f</li></ul></li><li class="src short"><a href="#v:mkGenHandler">mkGenHandler</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> h p i o e -&gt; (<a href="Rest-Handler.html#t:Env">Env</a> h p i -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m (<a href="Rest-Handler.html#t:Apply">Apply</a> f o)) -&gt; <a href="Rest-Handler.html#t:GenHandler">GenHandler</a> m f</li><li class="src short"><span class="keyword">type family</span> <a href="#t:Apply">Apply</a> f a :: *</li><li class="src short"><span class="keyword">type</span> <a href="#t:Handler">Handler</a> m = <a href="Rest-Handler.html#t:GenHandler">GenHandler</a> m <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Identity.html#t:Identity">Identity</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:ListHandler">ListHandler</a> m = <a href="Rest-Handler.html#t:GenHandler">GenHandler</a> m []</li><li class="src short"><a href="#v:secureHandler">secureHandler</a> ::  <a href="Rest-Handler.html#t:Handler">Handler</a> m -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m</li></ul></div><div id="interface"><h1 id="g:1">Single handlers.</h1><div class="top"><p class="src"><a name="v:mkHandler" class="def">mkHandler</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> h p i o e -&gt; (<a href="Rest-Handler.html#t:Env">Env</a> h p i -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m o) -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m <a href="src/Rest-Handler.html#mkHandler" class="link">Source</a></p><div class="doc"><p>Create a handler for a single resource. Takes the entire
 environmend as input.</p></div></div><div class="top"><p class="src"><a name="v:mkInputHandler" class="def">mkInputHandler</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> () () i o e -&gt; (i -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m o) -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m <a href="src/Rest-Handler.html#mkInputHandler" class="link">Source</a></p><div class="doc"><p>Create a handler for a single resource. Takes only the body
 information as input.</p></div></div><div class="top"><p class="src"><a name="v:mkConstHandler" class="def">mkConstHandler</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> () () () o e -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m o -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m <a href="src/Rest-Handler.html#mkConstHandler" class="link">Source</a></p><div class="doc"><p>Create a handler for a single resource. Doesn't take any input.</p></div></div><div class="top"><p class="src"><a name="v:mkIdHandler" class="def">mkIdHandler</a> :: MonadReader id m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> h p i o e -&gt; (i -&gt; id -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m o) -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m <a href="src/Rest-Handler.html#mkIdHandler" class="link">Source</a></p><div class="doc"><p>Create a handler for a single resource. Take body information and
 the resource identifier as input. The monad <code>m</code> should be a
 <code><a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Reader.html#t:Reader">Reader</a></code>-like type containing the idenfier.</p></div></div><h1 id="g:2">Listings.</h1><div class="top"><p class="src"><a name="v:mkListing" class="def">mkListing</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> () () () o e -&gt; (<a href="Rest-Handler.html#t:Range">Range</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m [o]) -&gt; <a href="Rest-Handler.html#t:ListHandler">ListHandler</a> m <a href="src/Rest-Handler.html#mkListing" class="link">Source</a></p><div class="doc"><p>Smart constructor for creating a list handler.</p></div></div><div class="top"><p class="src"><a name="v:mkOrderedListing" class="def">mkOrderedListing</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> () () () o e -&gt; ((<a href="Rest-Handler.html#t:Range">Range</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>) -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m [o]) -&gt; <a href="Rest-Handler.html#t:ListHandler">ListHandler</a> m <a href="src/Rest-Handler.html#mkOrderedListing" class="link">Source</a></p><div class="doc"><p>Create a list handler that accepts ordering information.</p></div></div><h2 id="g:3">Parameter parsers for listings.</h2><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Range" class="def">Range</a> <a href="src/Rest-Handler.html#Range" class="link">Source</a></p><div class="doc"><p>Data type for representing the requested range in list handlers.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Range" class="def">Range</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:offset" class="def">offset</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:count" class="def">count</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:range" class="def">range</a> :: <a href="Rest-Dictionary-Types.html#t:Param">Param</a> <a href="Rest-Handler.html#t:Range">Range</a> <a href="src/Rest-Handler.html#range" class="link">Source</a></p><div class="doc"><p>Dictionary for taking <code><a href="Rest-Handler.html#t:Range">Range</a></code> parameters. Allows two query
 parameters, <code>offset</code> and <code>count</code>. If not passed, the defaults are 0
 and 100. The maximum range that can be passed is 1000.</p></div></div><div class="top"><p class="src"><a name="v:orderedRange" class="def">orderedRange</a> :: <a href="Rest-Dictionary-Types.html#t:Param">Param</a> (<a href="Rest-Handler.html#t:Range">Range</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>) <a href="src/Rest-Handler.html#orderedRange" class="link">Source</a></p><div class="doc"><p>Dictionary for taking ordering information. In addition to the
 parameters accepted by <code><a href="Rest-Handler.html#v:range">range</a></code>, this accepts <code>order</code> and
 <code>direction</code>.</p></div></div><h1 id="g:4">Generic handlers and core data types.</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Env" class="def">Env</a> h p i <a href="src/Rest-Handler.html#Env" class="link">Source</a></p><div class="doc"><p>An environment of inputs passed to a handler. Contains
 information from the <code><a href="Rest-Handler.html#v:header">header</a></code>s, the <code><a href="Rest-Handler.html#v:param">param</a></code>eters and the body
 <code><a href="Rest-Handler.html#v:input">input</a></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Env" class="def">Env</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:header" class="def">header</a> :: h</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:param" class="def">param</a> :: p</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:input" class="def">input</a> :: i</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:GenHandler" class="def">GenHandler</a> m f <span class="keyword">where</span> <a href="src/Rest-Handler.html#GenHandler" class="link">Source</a></p><div class="doc"><p>A handler for some endpoint. The input and output types are
 specified by the <code><a href="Rest-Handler.html#v:dictionary">dictionary</a></code>, which can be created using the
 combinators from <a href="Rest-Dictionary-Combinators.html">Rest.Dictionary.Combinators</a>. The inputs
 (headers, parameters and body) are passed as an <code><a href="Rest-Handler.html#t:Env">Env</a></code> to the
 <code><a href="Rest-Handler.html#v:handler">handler</a></code>. This handler runs in monad <code>m</code>, combined with the
 ability to throw errors. The result is either the output value, or
 a list of them for list handlers.
 If the <code><a href="Rest-Handler.html#v:secure">secure</a></code> flag is set, this suggests to clients that the
 resource should only be served over https. It has no effect when
 running the API.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:GenHandler" class="def">GenHandler</a> ::  <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e -&gt; (<a href="Rest-Handler.html#t:Env">Env</a> h p i -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m (<a href="Rest-Handler.html#t:Apply">Apply</a> f o)) -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Rest-Handler.html#t:GenHandler">GenHandler</a> m f</td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:dictionary" class="def">dictionary</a> :: <a href="Rest-Dictionary-Types.html#t:Dict">Dict</a> h p i o e</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:handler" class="def">handler</a> :: <a href="Rest-Handler.html#t:Env">Env</a> h p i -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m (<a href="Rest-Handler.html#t:Apply">Apply</a> f o)</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:secure" class="def">secure</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:mkGenHandler" class="def">mkGenHandler</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a> h p i o e -&gt; (<a href="Rest-Handler.html#t:Env">Env</a> h p i -&gt; <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> (Reason e) m (<a href="Rest-Handler.html#t:Apply">Apply</a> f o)) -&gt; <a href="Rest-Handler.html#t:GenHandler">GenHandler</a> m f <a href="src/Rest-Handler.html#mkGenHandler" class="link">Source</a></p><div class="doc"><p>Construct a <code><a href="Rest-Handler.html#t:GenHandler">GenHandler</a></code> using a <code><a href="Rest-Dictionary-Types.html#t:Modifier">Modifier</a></code> instead of a <code><a href="Rest-Dictionary-Types.html#t:Dict">Dict</a></code>.
 The <code><a href="Rest-Handler.html#v:secure">secure</a></code> flag will be <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:False">False</a></code>.</p></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a name="t:Apply" class="def">Apply</a> f a :: * <a href="src/Rest-Handler.html#Apply" class="link">Source</a></p><div class="doc"><p>Apply a Functor <code>f</code> to a type <code>a</code>. In general will result in <code>f
 a</code>, except if <code>f</code> is <code><a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Identity.html#t:Identity">Identity</a></code>, in which case it will result in
 <code>a</code>. This prevents a lot of <code><a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Identity.html#t:Identity">Identity</a></code> wrapping/unwrapping.</p></div><div class="subs instances"><p id="control.i:Apply" class="caption collapser" onclick="toggleSection('i:Apply')">Instances</p><div id="section.i:Apply" class="show"><table><tr><td class="src"><span class="keyword">type</span> <a href="Rest-Handler.html#t:Apply">Apply</a> [] a = [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="Rest-Handler.html#t:Apply">Apply</a> <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Identity.html#t:Identity">Identity</a> a = a</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Handler" class="def">Handler</a> m = <a href="Rest-Handler.html#t:GenHandler">GenHandler</a> m <a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Identity.html#t:Identity">Identity</a> <a href="src/Rest-Handler.html#Handler" class="link">Source</a></p><div class="doc"><p>A <code><a href="Rest-Handler.html#t:Handler">Handler</a></code> returning a single item.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:ListHandler" class="def">ListHandler</a> m = <a href="Rest-Handler.html#t:GenHandler">GenHandler</a> m [] <a href="src/Rest-Handler.html#ListHandler" class="link">Source</a></p><div class="doc"><p>A <code><a href="Rest-Handler.html#t:Handler">Handler</a></code> returning a list of items.</p></div></div><h1 id="g:5">Convenience functions.</h1><div class="top"><p class="src"><a name="v:secureHandler" class="def">secureHandler</a> ::  <a href="Rest-Handler.html#t:Handler">Handler</a> m -&gt; <a href="Rest-Handler.html#t:Handler">Handler</a> m <a href="src/Rest-Handler.html#secureHandler" class="link">Source</a></p><div class="doc"><p>Set <code><a href="Rest-Handler.html#v:secure">secure</a></code> to <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Bool.html#v:True">True</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.2</p></div></body></html>