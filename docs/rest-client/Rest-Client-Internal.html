<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Rest.Client.Internal</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Rest-Client-Internal.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Rest-Client-Internal.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">rest-client-0.4: Utility library for use in generated API client libraries.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Rest.Client.Internal</p></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short">module <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html">Control.Monad</a></li><li class="src short">module <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html">Data.String</a></li><li class="src short"><span class="keyword">class</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="#t:MonadIO">MonadIO</a> m <span class="keyword">where</span><ul class="subs"><li><a href="#v:liftIO">liftIO</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/System-IO.html#t:IO">IO</a> a -&gt; m a</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:ByteString">ByteString</a> :: *</li><li class="src short"><a href="#v:intercalate">intercalate</a> ::  [a] -&gt; [[a]] -&gt; [a]</li><li class="src short"><a href="#v:encode">encode</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></li><li class="src short">module <a href="Rest-Client-Base.html">Rest.Client.Base</a></li><li class="src short"><span class="keyword">class</span> <a href="#t:ShowUrl">ShowUrl</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:showUrl">showUrl</a> :: a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></li></ul></li><li class="src short"><a href="#v:hAccept">hAccept</a> :: HeaderName</li><li class="src short"><a href="#v:hContentType">hContentType</a> :: HeaderName</li><li class="src short"><span class="keyword">data</span> <a href="#t:ApiRequest">ApiRequest</a> = <a href="#v:ApiRequest">ApiRequest</a> {<ul class="subs"><li><a href="#v:method">method</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></li><li><a href="#v:uri">uri</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></li><li><a href="#v:params">params</a> :: [(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>)]</li><li><a href="#v:requestHeaders">requestHeaders</a> :: RequestHeaders</li><li><a href="#v:requestBody">requestBody</a> :: <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></li></ul>}</li><li class="src short"><a href="#v:doRequest">doRequest</a> :: <a href="Rest-Client-Base.html#t:ApiStateC">ApiStateC</a> m =&gt; (<a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; Reason e) -&gt; (<a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; a) -&gt; <a href="Rest-Client-Internal.html#t:ApiRequest">ApiRequest</a> -&gt; m (<a href="Rest-Client-Base.html#t:ApiResponse">ApiResponse</a> e a)</li><li class="src short"><a href="#v:parseResult">parseResult</a> ::  (<a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; Reason e) -&gt; (<a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; a) -&gt; Response <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; <a href="Rest-Client-Base.html#t:ApiResponse">ApiResponse</a> e a</li><li class="src short"><a href="#v:fromJSON">fromJSON</a> :: FromJSON a =&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; a</li><li class="src short"><a href="#v:toJSON">toJSON</a> :: ToJSON a =&gt; a -&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:fromXML">fromXML</a> :: XmlStringToType a =&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; a</li><li class="src short"><a href="#v:toXML">toXML</a> :: XmlStringToType a =&gt; a -&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:makeReq">makeReq</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> -&gt; [[<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>]] -&gt; [(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>)] -&gt; RequestHeaders -&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; <a href="Rest-Client-Internal.html#t:ApiRequest">ApiRequest</a></li><li class="src short"><a href="#v:doReq">doReq</a> :: (<a href="Rest-Client-Base.html#t:ApiStateC">ApiStateC</a> m, <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m) =&gt; <a href="Rest-Client-Internal.html#t:ApiRequest">ApiRequest</a> -&gt; m (Response <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a>)</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src">module <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html">Control.Monad</a></p></div><div class="top"><p class="src">module <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html">Data.String</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a name="t:MonadIO" class="def">MonadIO</a> m <span class="keyword">where</span></p><div class="doc"><p>Monads in which <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/System-IO.html#t:IO">IO</a></code> computations may be embedded.
 Any monad built by applying a sequence of monad transformers to the
 <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/System-IO.html#t:IO">IO</a></code> monad will be an instance of this class.</p><p>Instances should satisfy the following laws, which state that <code><a href="Rest-Client-Internal.html#v:liftIO">liftIO</a></code>
 is a transformer of monads:</p><ul><li><pre><code><a href="Rest-Client-Internal.html#v:liftIO">liftIO</a></code> . <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#v:return">return</a></code> = <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Control-Monad.html#v:return">return</a></code></pre></li><li><pre><code><a href="Rest-Client-Internal.html#v:liftIO">liftIO</a></code> (m &gt;&gt;= f) = <code><a href="Rest-Client-Internal.html#v:liftIO">liftIO</a></code> m &gt;&gt;= (<code><a href="Rest-Client-Internal.html#v:liftIO">liftIO</a></code> . f)</pre></li></ul></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:liftIO" class="def">liftIO</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/System-IO.html#t:IO">IO</a> a -&gt; m a</p><div class="doc"><p>Lift a computation from the <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/System-IO.html#t:IO">IO</a></code> monad.</p></div></div><div class="subs instances"><p id="control.i:MonadIO" class="caption collapser" onclick="toggleSection('i:MonadIO')">Instances</p><div id="section.i:MonadIO" class="show"><table><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/System-IO.html#t:IO">IO</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Maybe.html#t:MaybeT">MaybeT</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-List.html#t:ListT">ListT</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Identity.html#t:IdentityT">IdentityT</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (ExceptionT m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (ResourceT m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="Rest-Client-Base.html#t:ApiT">ApiT</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> w, <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m) =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Writer-Strict.html#t:WriterT">WriterT</a> w m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> w, <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m) =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Writer-Lazy.html#t:WriterT">WriterT</a> w m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-State-Strict.html#t:StateT">StateT</a> s m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a> r m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:Error">Error</a> e, <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m) =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html#t:ErrorT">ErrorT</a> e m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Cont.html#t:ContT">ContT</a> r m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> w, <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m) =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-RWS-Strict.html#t:RWST">RWST</a> r w s m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> w, <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m) =&gt; <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> (<a href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-RWS-Lazy.html#t:RWST">RWST</a> r w s m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ByteString" class="def">ByteString</a> :: *</p><div class="doc"><p>A space-efficient representation of a <code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Word.html#t:Word8">Word8</a></code> vector, supporting many
 efficient operations.</p><p>A lazy <code><a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></code> contains 8-bit bytes, or by using the operations
 from <a href="http://hackage.haskell.org/packages/archive/bytestring/0.10.4.0/doc/html/Data-ByteString-Lazy-Char8.html">Data.ByteString.Lazy.Char8</a> it can be interpreted as containing
 8-bit characters.</p></div><div class="subs instances"><p id="control.i:ByteString" class="caption collapser" onclick="toggleSection('i:ByteString')">Instances</p><div id="section.i:ByteString" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Data.html#t:Data">Data</a> <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Read.html#t:Read">Read</a> <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:IsString">IsString</a> <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/deepseq/1.3.0.2/doc/html/Control-DeepSeq.html#t:NFData">NFData</a> <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">FoldCase <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Semigroup <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">ToString <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> * <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:intercalate" class="def">intercalate</a> ::  [a] -&gt; [[a]] -&gt; [a]</p><div class="doc"><p><code><a href="Rest-Client-Internal.html#v:intercalate">intercalate</a></code> <code>xs xss</code> is equivalent to <code>(<code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-List.html#v:concat">concat</a></code> (<code><a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-List.html#v:intersperse">intersperse</a></code> xs xss))</code>.
 It inserts the list <code>xs</code> in between the lists in <code>xss</code> and concatenates the
 result.</p></div></div><div class="top"><p class="src"><a name="v:encode" class="def">encode</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></p></div><div class="top"><p class="src">module <a href="Rest-Client-Base.html">Rest.Client.Base</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ShowUrl" class="def">ShowUrl</a> a <span class="keyword">where</span></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:showUrl" class="def">showUrl</a> :: a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></p></div><div class="subs instances"><p id="control.i:ShowUrl" class="caption collapser" onclick="toggleSection('i:ShowUrl')">Instances</p><div id="section.i:ShowUrl" class="show"><table><tr><td class="src"><a href="Rest-Client-Internal.html#t:ShowUrl">ShowUrl</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-Int.html#t:Int">Int</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:ShowUrl">ShowUrl</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Prelude.html#t:Integer">Integer</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:ShowUrl">ShowUrl</a> <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:ShowUrl">ShowUrl</a> Text</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:ShowUrl">ShowUrl</a> Text</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Rest-Client-Internal.html#t:ShowUrl">ShowUrl</a> UUID</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:hAccept" class="def">hAccept</a> :: HeaderName</p></div><div class="top"><p class="src"><a name="v:hContentType" class="def">hContentType</a> :: HeaderName</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ApiRequest" class="def">ApiRequest</a> <a href="src/Rest-Client-Internal.html#ApiRequest" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ApiRequest" class="def">ApiRequest</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:method" class="def">method</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:uri" class="def">uri</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:params" class="def">params</a> :: [(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>)]</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:requestHeaders" class="def">requestHeaders</a> :: RequestHeaders</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:requestBody" class="def">requestBody</a> :: <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:doRequest" class="def">doRequest</a> :: <a href="Rest-Client-Base.html#t:ApiStateC">ApiStateC</a> m =&gt; (<a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; Reason e) -&gt; (<a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; a) -&gt; <a href="Rest-Client-Internal.html#t:ApiRequest">ApiRequest</a> -&gt; m (<a href="Rest-Client-Base.html#t:ApiResponse">ApiResponse</a> e a) <a href="src/Rest-Client-Internal.html#doRequest" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:parseResult" class="def">parseResult</a> ::  (<a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; Reason e) -&gt; (<a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; a) -&gt; Response <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; <a href="Rest-Client-Base.html#t:ApiResponse">ApiResponse</a> e a <a href="src/Rest-Client-Internal.html#parseResult" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:fromJSON" class="def">fromJSON</a> :: FromJSON a =&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; a <a href="src/Rest-Client-Internal.html#fromJSON" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:toJSON" class="def">toJSON</a> :: ToJSON a =&gt; a -&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> <a href="src/Rest-Client-Internal.html#toJSON" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:fromXML" class="def">fromXML</a> :: XmlStringToType a =&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; a <a href="src/Rest-Client-Internal.html#fromXML" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:toXML" class="def">toXML</a> :: XmlStringToType a =&gt; a -&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> <a href="src/Rest-Client-Internal.html#toXML" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:makeReq" class="def">makeReq</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a> -&gt; [[<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>]] -&gt; [(<a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.7.0.0/doc/html/Data-String.html#t:String">String</a>)] -&gt; RequestHeaders -&gt; <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a> -&gt; <a href="Rest-Client-Internal.html#t:ApiRequest">ApiRequest</a> <a href="src/Rest-Client-Internal.html#makeReq" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:doReq" class="def">doReq</a> :: (<a href="Rest-Client-Base.html#t:ApiStateC">ApiStateC</a> m, <a href="Rest-Client-Internal.html#t:MonadIO">MonadIO</a> m) =&gt; <a href="Rest-Client-Internal.html#t:ApiRequest">ApiRequest</a> -&gt; m (Response <a href="Rest-Client-Internal.html#t:ByteString">ByteString</a>) <a href="src/Rest-Client-Internal.html#doReq" class="link">Source</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.2</p></div></body></html>